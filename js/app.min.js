(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acceptDownload = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/* global fetch, Headers */

// Promise polyfill
global.Promise = global.Promise || require('promise-polyfill')

// Fetch polyfill
require('whatwg-fetch')

var FileSaver = require('file-saver')

function acceptDownload (url, accept, filename, options) {
  options = options || {}
  options.headers = new Headers(options.headers)
  options.headers.set('accept', accept)

  return fetch(url, options).then(function (res) {
    return res.blob()
  }).then(function (blob) {
    FileSaver.saveAs(blob, filename)
  })
}

acceptDownload.attach = function () {
  var elements = document.querySelectorAll('[data-accept]')

  for (var i = 0; i < elements.length; i++) {
    elements[i].onclick = function (event) {
      event.preventDefault()

      var url = this.href
      var accept = this.attributes.getNamedItem('data-accept').value
      var filename = this.href.split('/').pop()

      acceptDownload(url, accept, filename)
    }
  }
}

module.exports = acceptDownload

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"file-saver":2,"promise-polyfill":3,"whatwg-fetch":4}],2:[function(require,module,exports){
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
  define("FileSaver.js", function() {
    return saveAs;
  });
}

},{}],3:[function(require,module,exports){
(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    return new Promise(function (resolve, reject) {
      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

},{}],4:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}]},{},[1])(1)
});
(function ($) {

    function DataLoader(endPoint, pageSize, preLoadExtent) {
        var totalCount = 40;
        var data = { length: 0 }; // the data rows, which we'll fill in, plus an extra property for total length
        var pagesToLoad = {};
        var columns = [];
        var filters = []; // {column: "pollutant", comperator: "=", literal: "O3"} 
        var filterRequestStatus = {};
        var distinctValues = {}; // distinct column values: { "station" : ["Aarau", "Aargau"], ... }
        var dataXHR = [];
        var countXHR = null;
        var languages = [];
        var selectedLang = "";
        var datastructuredefinition = "";
        var datasetname = "";
        var datasetcomment = "";
        var fallbackLanguage = "de";
        
        // bundle individual sparql query parts in an object for now
        var sparqlQuery = {
            prologue: "",
            outerSelect: "SELECT * WHERE",
            query: "",
            orderBy: "",
            filters: "",
            limit: ""
        };
        
        // events
        var onDataLoading = new Slick.Event();
        var onDataLoaded = new Slick.Event();
        var onColumnsChanged = new Slick.Event();
        var onRowCountChanged = new Slick.Event();
        var onFilterValuesRetrieved = new Slick.Event();
        var onErrorOccurred = new Slick.Event();
        var onLanguageOptionsRetrieved = new Slick.Event();
        var onDatasetMetadataRetrieved = new Slick.Event();

        function initFromDataCube(dsd, initialFilter) {
            initialFilter = initialFilter || [];
            datastructuredefinition = dsd;
            queryLanguageOptions(function() {
                queryDataStructureMetadata();
                queryDataStructureDefinition(function() {
                    setFilters(initialFilter);
                });
            });
        }


        function clearData() {
            for (var key in data) {
                delete data[key];
            }
            data.length = totalCount;
            pagesToLoad = {};

            // abort all running xhr requests for data
            abortAllDataRequests();
        }

        function clearColumns() {
            columns = [];
        }
        

        function queryLanguageOptions(complete)
        {

            var query = "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
                "SELECT DISTINCT ?languages WHERE {" +
                "?s rdfs:label ?o." +
                "BIND(LANG(?o) as ?languages)} ORDER BY ?languages ";

            var req = $.ajax({
                dataType: "json",
                type: "GET",
                data: { query: query },
                url: endPoint,
                callbackParameter: "callback",
                headers : {
                    Accept : 'application/sparql-results+json'
                },
                cache: true,
                success: function (resp, textStatus, jqXHR) {

                    var result;
                    for(var i in resp.results.bindings) {
                        result = resp.results.bindings[i].languages.value;

                        if(result !== "" && result.length == 2)
                            languages.push(result);
                    }

                    if(result.length > 0)
                        selectedLang = languages[0];

                    onLanguageOptionsRetrieved.notify(languages);

                    if(complete)
                        complete();
                },
                error: function () {
                    console.log("couldn't load languages");
                }
            });

        }

        function setLanguage(lang) {
            selectedLang = lang;
            queryDataStructureDefinition();
        }

        
        function loadColumnInfo() {  
            var query = "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
            "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
            "PREFIX qb: <http://purl.org/linked-data/cube#>" +
            "SELECT DISTINCT ?datasetname ?datasetcomment WHERE { " +
            "<" + datastructuredefinition + "> a qb:DataStructureDefinition ." +
            "?dataset a qb:DataSet." +
            "?dataset rdfs:label ?datasetname." +
            "?dataset rdfs:comment ?datasetcomment." +
            "?dataset qb:structure <" + datastructuredefinition + ">" +
            "}";


            var req = $.ajax({
                dataType: "json",
                type: "GET",
                data: { query: query },
                url: endPoint,
                callbackParameter: "callback",
                headers : {
                    Accept : 'application/sparql-results+json'
                },
                cache: true,
                success: function (resp, textStatus, jqXHR) {
                    
                        datasetname = resp.results.bindings[0].datasetname.value;
                        datasetcomment = resp.results.bindings[0].datasetcomment.value;
                        onDatasetMetadataRetrieved.notify({name: datasetname, comment: datasetcomment });

                },
                error: function () {
                    console.log("couldn't dataset name and comment");
                }
            });

            /*

            // set the columns if not already set.
            if (columns.length === 0) {
                var vars = responseData.head.vars;
                $.each(vars, function (i, col) {
                    columns.push({ id: col, name: col, field: col, sortable: true });
                    
                });
                onColumnsChanged.notify(columns);                
            }
            */
        }
        function queryDataStructureMetadata() {

            var query = "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>" +
            "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>" +
            "PREFIX qb: <http://purl.org/linked-data/cube#>" +
            "SELECT DISTINCT ?datasetname ?datasetcomment WHERE { " +
            "<" + datastructuredefinition + "> a qb:DataStructureDefinition ." +
            "?dataset a qb:DataSet." +
            "?dataset rdfs:label ?datasetname." +
            "?dataset rdfs:comment ?datasetcomment." +
            "?dataset qb:structure <" + datastructuredefinition + ">" +
            "}";


            var req = $.ajax({
                dataType: "json",
                type: "GET",
                data: { query: query },
                url: endPoint,
                callbackParameter: "callback",
                headers : {
                    Accept : 'application/sparql-results+json'
                },
                cache: true,
                success: function (resp, textStatus, jqXHR) {
                    
                        datasetname = resp.results.bindings[0].datasetname.value;
                        datasetcomment = resp.results.bindings[0].datasetcomment.value;
                        onDatasetMetadataRetrieved.notify({name: datasetname, comment: datasetcomment });

                },
                error: function () {
                    console.log("couldn't dataset name and comment");
                }
            });
        }

        // load data cube definition
        function queryDataStructureDefinition(complete) {

            var query = "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n" + 
            "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n" + 
            "PREFIX qb: <http://purl.org/linked-data/cube#>\n" + 
            "SELECT DISTINCT ?column ?columnLabel ?columnComment ?componentType WHERE {\n" + 
            "<" + datastructuredefinition + "> a qb:DataStructureDefinition .\n" +
            "<" + datastructuredefinition + "> ?p ?component .\n" + 
            "?component ?componentType ?column.\n" +
            "FILTER(?componentType != qb:order)\n" +
            "?component qb:order ?order.\n" +

            "OPTIONAL { \n" +
            "  ?column rdfs:label ?columnLabel.\n" +
            "  FILTER(LANGMATCHES(lang(?columnLabel), '" + selectedLang + "'))\n" + 
            "}\n" + 
//            "OPTIONAL { \n" +
//            "  ?column rdfs:label ?columnLabelDefaultLang .\n" +
//            "  FILTER(LANGMATCHES(lang(?columnLabelDefaultLang), '" + fallbackLanguage + "'))\n" + 
//            "}\n" + 
//            "BIND(COALESCE(?columnLabelUserLang, ?columnLabelDefaultLang) AS ?columnLabel)\n" +

            "OPTIONAL { \n" +
            "  ?column <http://www.w3.org/2000/01/rdf-schema#comment> ?columnComment .\n" +
            "  FILTER(LANGMATCHES(lang(?columnCommentUserLang), '" + selectedLang + "'))\n" + 
            "}\n" + 
//            "OPTIONAL { \n" +
//            "  ?column <http://www.w3.org/2000/01/rdf-schema#comment> ?columnCommentDefaultLang .\n" +
//            "  FILTER(LANGMATCHES(lang(?columnCommentDefaultLang), '" + fallbackLanguage + "'))\n" + 
//            "}\n" + 
//            "BIND(COALESCE(?columnCommentUserLang, ?columnCommentDefaultLang) AS ?columnComment)\n" +
            "}\n" +
            "ORDER BY ?order";

            // load dsd and build our query
            var req = $.ajax({
                dataType: "json",
                type: "GET",
                data: { query: query },
                url: endPoint,
                callbackParameter: "callback",
                headers : {
                    Accept : 'application/sparql-results+json'
                },
                cache: true,
                success: function (resp, textStatus, jqXHR) {
                    //console.log("DSD QUERY RESPONSE:\n");
                    //console.log(JSON.stringify(resp.results.bindings));

                    var newQuery = "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n" +
                    "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n" +
                    "\n";

                    // add column selectors
                    newQuery += "SELECT DISTINCT ";
                    for(var i in resp.results.bindings)   {
                        var colV = /[^/]*$/.exec(resp.results.bindings[i].column.value)[0];
                        newQuery += "?" + colV + "Value "; // todo: careful, if more than one language this part will fail!
                    }
                    newQuery += " WHERE {\n" +
                        "?m <http://purl.org/linked-data/cube#dataSet> ?dataset.\n" +
                        "?dataset <http://purl.org/linked-data/cube#structure> <"+ datastructuredefinition +"> .\n";

                    for(i in resp.results.bindings)  {
                        var binding = resp.results.bindings[i];
                        var col = /[^/]*$/.exec(binding.column.value)[0];
                        var colValueUserLang = col + "UserLang";
                        var colValueDefaultLang = col + "DefaultLang";
                        var colValue = col + "Value";
                        var columnComment = (binding.columnComment !== undefined) ? binding.columnComment.value : "";
                        var columnLabel = (binding.columnLabel !== undefined) ? binding.columnLabel.value : binding.column.value;
                        columns.push({ id: colValue, name: columnLabel, field: colValue, sortable: true, comment: columnComment, componentType: binding.componentType.value });  

                        // circumvent missing limits values problem, needs fix
                        if (binding.column.value == 'http://environment.data.admin.ch/ubd/28/qb/limitvalue') {
                            newQuery += "OPTIONAL {\n";
                        }

                        newQuery += "?m <" + binding.column.value + "> ?" + col + ".\n" +
                        "OPTIONAL { \n" +
                        "  ?" + col + " rdfs:label ?" + colValueUserLang + ".\n" +
                        "  FILTER(LANGMATCHES(lang(?" + colValueUserLang + "), '" + selectedLang + "') || lang(?" + colValueUserLang + ") = '')\n" +
                        "}\n" +
                        // go and get the fallback language value as well
//                        "OPTIONAL { \n" +
//                        "  ?" + col + " rdfs:label ?" + colValueDefaultLang + ".\n" +
//                        "  FILTER(LANGMATCHES(lang(?" + colValueDefaultLang + "), '" + fallbackLanguage + "') || lang(?" + colValueDefaultLang + ") = '')\n" +
//                        "}\n" +
                        // finally choose assign the correct language to ?col
                        "BIND(COALESCE(?" + colValueUserLang + ", ?" + col + ") AS ?" + colValue + ")\n\n";
//                        "BIND(COALESCE(?" + colValueUserLang + ", ?" + colValueDefaultLang + ", ?" + col + ") AS ?" + colValue + ")\n\n";

                        if (binding.column.value == 'http://environment.data.admin.ch/ubd/28/qb/limitvalue') {
                            newQuery += "}\n";
                        }


                    }
                    newQuery += "}";

                    onColumnsChanged.notify(columns); 

                    //console.log("\nGENERATED QUERY: \n\n" + newQuery);
                    setQuery(newQuery);
                    if(complete)
                        complete();
                    ensureData(0, 1000);

                },
                error: function () {
                    console.log("couldn't load dsd");
                }
            });

        }

        // from and to are 0-based row indices.
        function ensureData(from, to) {
            if (totalCount <= 0)
                return;

            data.length = totalCount;

            from -= preLoadExtent;
            to += preLoadExtent;

            // clamp from 0 to data.length - 1
            from = Math.min(Math.max(from, 0), data.length - 1);
            to = Math.min(Math.max(to, 0), data.length - 1);

            var fromPage = Math.floor(from / pageSize);
            var toPage = Math.floor(to / pageSize);

            //console.log("ensure data " + from + " " + to);

            for (var page = fromPage; page <= toPage; page++) {
                if (pagesToLoad[page] === undefined) {
                    pagesToLoad[page] = null;
                }
            }

            // do a bunch of queries to get the data for the range.
            // todo: remove this batching code, it doesn't do anything at the moment
            //       and if it did it wouldn't work properly because
            //       we added that abort code. It only works because we only load
            //       one page at a time
            for (page = fromPage; page <= toPage; page++) {
                if (pagesToLoad[page] === null) {
                    onDataLoading.notify({ from: from, to: to });
                    setLimit(page, pageSize);
                    loaderFunction.call(this, page);
                }
            }
        }

        // todo: can we reset the sort? 
        function setSort(field, sortAsc) {
            // todo: use a nicer way to set asc/desc here
            sparqlQuery.orderBy = "ORDER BY " + ((sortAsc) ? "ASC" : "DESC") + "(?" + field + ")";
        }

        function setQuery(query, complete) {
            // extract the prologue from the query (PREFIX|BASE)
            // probably better to change later to a sparql parser https://github.com/RubenVerborgh/SPARQL.js
            var re = /.*(PREFIX|BASE).*\n/g; 
            var prologue;
            sparqlQuery.prologue = "";
            sparqlQuery.query = query;
                
            while((prologue = re.exec(query)) !== null) {
                sparqlQuery.prologue += prologue[0] ;
                sparqlQuery.query = sparqlQuery.query.replace(prologue[0], '');
            }
                        
            // make sure our total count is still correct
            updateTotalCount(complete);
        }

        function setLimit(page, limit) {
            sparqlQuery.limit = "LIMIT " + limit + " OFFSET " + (page * limit);
        }

        function abortAllDataRequests()
        {
            for(var i in dataXHR)
            {
                dataXHR[i].abort();
            }

            dataXHR = [];

            // console.log("ABORTED ALL DATA REQUESTS!");
        }

        /** Adds a new comparison filter to this loader. 
        @param  filterObj   ex.: {station: [], measurement: [], ... }
        */
        function setFilters(filters)
        {
            // we can optimize our filter query based on the selected amount
            // of sort values.
            // if only one value is selected we can just add FILTER(?column = "value")
            // if all but one value is selected we can use FILTER(?column != "value")
            

            sparqlQuery.filters = {};
            $.each(filters, function (column, filterValues) {

                // continue if the filter has everything selected
                // or is not loaded at all
                if (/*typeof distinctValues[column] === 'undefined' || */
                    (filterValues.values.length === 0)) {
                    return true;
                }

                var moreSelected = filterValues.moreSelected === true || filterValues.moreSelected == "true";


                sparqlQuery.filters[column] = sparqlQuery.filters[column] || "";
                sparqlQuery.filters[column] += "FILTER(";

                $.each(filterValues.values, function (i, val) {

                    // default connector and comperator if we're using unchecked values
                    // then we want to filter with these two
                    var connector = " && ";
                    var comperator = " != ";
                    var isLastElement = filterValues.values.length - 1 == i;
                    if (!moreSelected) {
                        // if however there are less selected values than unchecked ones
                        // then we want to use the selected values for filtering
                        connector = " || ";
                        comperator = " = ";
                    }
                    
                    sparqlQuery.filters[column] +=
                        "STR(?" + column + ")" + comperator + "\"" + val + "\"";

                    if (!isLastElement)
                        sparqlQuery.filters[column] += connector;

                });

                sparqlQuery.filters[column] += ")\n";
            }); 
                 
        }

        function requestFilterData(columnId)
        {
            //console.log("requested filters for " + columnId);
            var queryObject = {
                outerSelect: "SELECT DISTINCT ?" + columnId + " WHERE",
                orderBy: "ORDER BY ASC(?" + columnId + ")"
            };

            var queryString = compileSparqlQuery({ useLimit: false, useFilters: true, excludeFilterColumns: [columnId] }, queryObject);
            var req = $.ajax({
                dataType: "json",
                type: "GET",
                data: { query: queryString },
                url: endPoint,
                callbackParameter: "callback",
                headers : {
                    Accept : 'application/sparql-results+json'
                },
                cache: true,
                success: function (resp, textStatus, jqXHR) {
                    var vals = [];
                    $.each(resp.results.bindings, function (i, binding) {
                        vals.push(binding[columnId].value);
                    });

                    // update our local version of distinct values for this col
                    distinctValues[columnId] = vals;

                    onFilterValuesRetrieved.notify({ column: columnId, values: vals });
                },
                error: function () {
                    onErrorOccurred.notify({ msg: "Can't reach the server." });
                    console.log("error retrieving filter values");
                }
            });
        }

        function updateTotalCount(complete)
        {
            if (countXHR && countXHR.readystate != 4) {
                countXHR.abort();
                //console.log("Aborted previous count request.");
            }
            //console.log("Sending new count request.");

            // todo: our event firing and exposing is a bit messy at the moment
            //       for example we expose this function 'updateTotalCount' to the user
            //       which is bad... mhhh k?
            //       oh yea, I'm also calling onDataLoading here to let the user
            //       know that we're doing something (counting rows) but it will get called
            //       again in a sec when the actual data is being loaded... good or bad?
            onDataLoading.notify();
            var queryString = compileSparqlQuery({ useLimit: false }, { outerSelect: "SELECT ( COUNT(*) as ?count) WHERE" });
            countXHR = $.ajax({
                dataType: "json",
                type: "GET",
                data: { query: queryString },
                url: endPoint,
                callbackParameter: "callback",
                headers : {
                    Accept : 'application/sparql-results+json'
                },
                cache: true,
                success: function (resp, textStatus, jqXHR) {
                    // the count query should always return with just one row and one column
                    // so our count result should be at 0 0
                    totalCount = parseInt(resp.results.bindings[0].count.value);
                    data.length = totalCount;
                    //console.log("recieved count request answer: " + totalCount + " rows");

                    onRowCountChanged.notify({ count: totalCount });

                    if (complete)
                        complete();
                },
                error: function () {
                    onErrorOccurred.notify({ msg: "Can't reach the server." });
                    console.log("error retrieving count query results");
                }
            });
        }
        
        function compileSparqlQuery(options, queryObject)
        {
            // set default values
            if (typeof options === 'undefined')
                options = {};
            if (typeof queryObject == 'undefined')
                queryObject = {};
            
            options.useSort = options.useSort !== false;
            options.useLimit = options.useLimit !== false;
            options.useFilters = options.useFilters !== false;
            options.excludeFilterColumns = options.excludeFilterColumns || [];

            queryObject.prologue = queryObject.prologue || sparqlQuery.prologue;
            queryObject.outerSelect = queryObject.outerSelect || sparqlQuery.outerSelect;
            queryObject.query = queryObject.query || sparqlQuery.query;
            queryObject.orderBy = queryObject.orderBy || sparqlQuery.orderBy;
            queryObject.filters = queryObject.filters || sparqlQuery.filters;
            queryObject.limit = queryObject.limit || sparqlQuery.limit;
            
            // check if we need limit, orderby or filters
            if (!options.useLimit)
                queryObject.limit = "";
            if (!options.useSort)
                queryObject.orderBy = "";

            var finalFilterString = "";
            if(options.useFilters) {
                // build final filter query
                for(var column in queryObject.filters)
                {
                    //console.log("options.excludeFilterColumns");
                    //console.log(options.excludeFilterColumns);
                    // if the exclude doesn't exists for the current column, add it
                    // to the final filter string
                    if (options.excludeFilterColumns.indexOf(column) == -1) {
                        finalFilterString += "#filters for " + 
                        column + "\n" + queryObject.filters[column] + "\n";
                    }
                    else {
                        //console.log("EXCLUDING A COLUMN");
                    }
                }
            }

            // build final query
            var queryString =
                queryObject.prologue +
                queryObject.outerSelect +
                "\n{\n{" + // inner filter block START
                queryObject.query +
                queryObject.orderBy +
                "\n}\n" + // inner filter block END
                finalFilterString +
                "}\n" + // outer select block END
                queryObject.limit;

            return queryString;
        }
        
        function compileQueryURL(options, queryObject) {
            var result = endPoint + "?query=" + encodeURIComponent(compileSparqlQuery(options, queryObject));
            return result;
        }

        function loaderFunction(page) {

            //console.log("Sending new data request.");

            // our sparql pages are 1-based.
            var queryString = compileSparqlQuery();
            var sparqlPage = page + 1;
            var xhr = $.ajax({
                dataType: 'json',
                type: 'GET',
                data: { query: queryString },
                url: endPoint,
                callbackParameter: "callback",
                headers : {
                    Accept : 'application/sparql-results+json'
                },
                cache: true,
                success: ajaxSuccess,
                error: function () {
                    onErrorOccurred.notify({ msg: "Can't reach the server." });
                    console.log('error loading page ' + page.toString());
                }
            });
            xhr.page = page;
            dataXHR.push(xhr);
        }

        function ajaxSuccess(responseData, textStatus, jqXHR) {
            //console.log("recieved data request answer.");

            // remove xhr from the dataXHR array
            dataXHR = dataXHR.filter(function (elem) {
                return elem != jqXHR;
            });

            // set the columns if not already set.
            if (columns.length === 0) {
                var vars = responseData.head.vars;
                $.each(vars, function (i, col) {
                    columns.push({ id: col, name: col, field: col, sortable: true });
                    
                });
                onColumnsChanged.notify(columns);                
            }
            var page = jqXHR.page;
            var rowsData = [];
            var results = responseData.results.bindings;
            // go through the results, and make rows data.
            for (var i = 0; i < results.length; i++) {
                var resultsRow = null;
                resultsRow = {};
                for (var col in results[i]) {
                    resultsRow[col] = results[i][col].value;
                }
                rowsData.push(resultsRow);
            }
            // set the page of data against the loader.
            setPageOfData(jqXHR.page, rowsData);
        }

        // given a page index, and an array of row data, set the data for the page
        function setPageOfData(page, rows) {

            pagesToLoad[page] = true; // set the page as loaded.
            var noOfRows = rows.length;
            var thisPageFrom = page * pageSize;
            var thisPageTo = thisPageFrom + noOfRows - 1;

            // fill the results in in data.
            for (var i = 0; i < noOfRows; i++) {

                // assign the row of results;
                data[thisPageFrom + i] = rows[i];
            }
            onDataLoaded.notify({ from: thisPageFrom, to: thisPageTo });
        }

        // public api.
        return {
            // properties
            "data": data,
            "sparqlQuery": sparqlQuery,

            // methods
            "clearColumns": clearColumns,
            "clearData": clearData,
            "ensureData": ensureData,
            "setPageOfData": setPageOfData,
            "setSort": setSort,
            "setQuery": setQuery,
            "setLimit": setLimit,
            "setFilters": setFilters,
            "compileQueryURL": compileQueryURL, // we temporarily expose this function to have the simple download functionality.
            "compileSparqlQuery": compileSparqlQuery,
            "updateTotalCount": updateTotalCount,
            "requestFilterData": requestFilterData,
            "setLanguage": setLanguage,
            "initFromDataCube": initFromDataCube,

            // events
            "onDataLoading": onDataLoading,
            "onDataLoaded": onDataLoaded,
            "onColumnsChanged": onColumnsChanged,
            "onRowCountChanged": onRowCountChanged,
            "onFilterValuesRetrieved": onFilterValuesRetrieved,
            "onErrorOccurred": onErrorOccurred,
            "onLanguageOptionsRetrieved": onLanguageOptionsRetrieved,
            "onDatasetMetadataRetrieved": onDatasetMetadataRetrieved
        };
    }

    $.extend(true, window, { udb: { DataLoader: DataLoader } });
})(jQuery);
